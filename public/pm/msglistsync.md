# 消息列表同步

## 一.需求

确认已读的消息对象实现多端同步,最多50个.

## 二.实现规则

### 2.1.客户端

这个功能上线时:
1. 客户端确认某个未读对象为已读或者新创建一个会话时,把该对象的id发送给服务端,服务端放在 `已读消息列表A` 中存储起来;
2. 客户端登录时向服务端发送时间来请求 `已读消息列表A` 的增量数据;
3. 客户端把登录时服务端下发的 `未读消息列表X` , 请求到的 `已读消息列表A1` 和 本地的 `已读消息列表A2` 做一下更新合并操作并刷新消息界面;
4. 客户端在做更新合并操作时要剔除请求到的 `已读消息列表A1` 中的异常id不显示;

### 2.2.服务端

#### 2.2.1.多端在线同步

现在好友,讨论组,群和帮派已做多端实时同步;

#### 2.2.2.离线下发

1. 原来的未读消息对象,仍然走原来的协议下发;
2. 服务端给每个人维护一个已读的 `已读消息列表A`, 列表中最多包含50项, 最新的位于最前面并且新的顶替旧的;
3. 服务端收到客户端新增id的协议时,如果列表A中不包含该id就执行增加id操作;
4. 服务端收到客户端附带时间的请求时,下发列表A的增量数据,其中下发的每一项需要包含 id,最近一条消息内容和时间;
5. 对于解散群,退出群,被移除群,被移除帮派,退出讨论组,被移除讨论组,删好友,被删好友等操作时也要去维护列表A;

## 三.待确认的问题

对于我已经不在的群,讨论组和帮派以及不是我的好友了的id列表该怎么维护?

目前想到以下三种方案:
* 在退群,退讨论组,解散群,删好友等操作时服务端去维护相关的列表A;
* 客户端在执行移除群成员等操作时告诉服务端去删除列表A中的相关id;
* 客户端在执行 2.1.-3. 中的更新合并操作时会剔除请求到的 `已读消息列表A1` 中的异常id,剔除完毕后告诉服务端也去移除列表A中的异常id;

> 确认使用 3